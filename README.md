# directsht

Direct spherical harmonic transform code for point sets on the sphere.
More details can be found in

http://arxiv.org/abs/2312.12285 \
Harmonic analysis of discrete tracers of large-scale structure

The code can be installed with
```
python3 -m pip install -v git+https://github.com/martinjameswhite/directsht
```
It requires numpy, scipy, healpy and numba.  If JAX is available, it can be used to
speed up the computation, but the code will automatically fall back to numpy
if JAX is not present.  Some of the notebooks use healpy for visualization, the
main code uses healpy only for coordinate rotations.

The code is much faster when run on GPUs. When they are available and JAX is installed, the code automatically distributes computation and memory across them.

***

## Usage

The code is relatively straightforward to use.  Given a set of points,
defined by arrays of theta and phi (in radians) and weights, the DirectSHT
class can be called to provide the spherical harmonic transform coefficients
alm.

First import the main class and create an instance:
```
from sht.sht import DirectSHT

# The class takes a number of multipoles to compute (lmax=Nl-1)
# and the number of spline points for interpolation.
# Typically Nx ~ Nl and Nx ~ 2 Nl is a conservative choice.
Nl = 500
Nx = 1024 
# Generate an instance of the class.
sht= DirectSHT(Nl,Nx)
```
If Nl and Nx are large then creating an instance can take a few seconds
because the code computes a table of spherical harmonics during initialization.

Then the transform can be done with
```
alms = sht(thetas,phis,weights)
```
The code returns a complex array stored in the same convention as Healpy
uses.  You can get the index of a given ell,m mode using the "indx" method
of the class.

We give several examples of how to compute alms for different sets of points,
do a pseudo-spectrum calculation for mock galaxies (generated by the LogNormalMocks
class and using the MaskDeconvolution class to handle the mode-coupling matrices
and window functions) and look at how the code performs in Jupyter notebooks within
the `notebooks` directory.  Please look there for further information.

#### Running our Jupyter notebooks on NERSC GPUs
Before you can run our JAX code on NERSC GPUs, you must ensure the `cudatoolkit` module can be used from within Jupyter. Instructions on how to do this can be found [here](https://docs.nersc.gov/development/languages/python/using-python-perlmutter/#using-cudatoolkit-module-in-jupyter). Similar steps may be required for other computing clusters.

